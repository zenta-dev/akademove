╔════════════════════════════════════════════════════════════════════════════════╗
║                    AKADEMOVE MERCHANT AVAILABILITY ANALYSIS                    ║
║                              EXPLORATION SUMMARY                               ║
╚════════════════════════════════════════════════════════════════════════════════╝

DOCUMENTS GENERATED:
  1. MERCHANT_AVAILABILITY_ANALYSIS.md (632 lines)
     - Comprehensive 11-section analysis
     - Current implementation structures
     - Detailed gaps and requirements
     - Implementation roadmap
  
  2. MERCHANT_AVAILABILITY_QUICK_REFERENCE.md (267 lines)
     - Quick lookup guide
     - Implementation checklist
     - Time estimates
     - Risk mitigation

═══════════════════════════════════════════════════════════════════════════════

EXPLORATION SCOPE COVERED:
  ✅ Merchant database tables & schemas
  ✅ Order handling & WebSocket integration
  ✅ Web UI patterns (React + TanStack Query)
  ✅ Mobile UI patterns (Flutter + BLoC)
  ✅ Real-time infrastructure (Durable Objects)
  ✅ Existing availability patterns (Driver reference)
  ✅ API handlers & repositories
  ✅ Error handling & logging

═══════════════════════════════════════════════════════════════════════════════

KEY FINDINGS:

WHAT EXISTS (✅):
  • Merchant table with isActive field (admin-only activation)
  • Merchant order handlers (accept, reject, markPreparing, markReady)
  • WebSocket infrastructure (OrderRoom Durable Object for real-time)
  • Order status with CANCELLED_BY_MERCHANT support
  • Driver availability pattern (DriverAvailabilityService) as reference
  • Web provider with TanStack Query integration
  • Mobile BLoC pattern for merchant features
  • Broadcast infrastructure for system announcements

WHAT'S MISSING (❌):
  CRITICAL:
    • isOnline & isTakingOrders fields on merchant table
    • operatingStatus enum (OPEN, CLOSED, BREAK, MAINTENANCE)
    • Business hours (start/end time) fields
    • MerchantAvailabilityService (should mimic Driver service)
    • /ws/merchant/:id WebSocket route
    • Merchant status toggle UI (web & mobile)
    • Order validation: check merchant is online before assignment
    • Auto-reject orders if merchant goes offline

  SECONDARY:
    • MERCHANT_STATUSES constant (only has MERCHANT_CATEGORIES)
    • Operating hours configuration endpoints
    • Timezone awareness for scheduling
    • Auto-pause orders during off-hours
    • Real-time merchant status broadcast to customers

═══════════════════════════════════════════════════════════════════════════════

ARCHITECTURE INSIGHTS:

DATABASE PATTERNS:
  • Drizzle ORM with PostgreSQL + PostGIS
  • Indexes established for: isActive, location (GIST), rating, created_at
  • Foreign keys properly defined (merchant → user, menu → merchant)
  • Numeric fields with proper precision (18,2 for prices)

REAL-TIME PATTERNS:
  • Cloudflare Durable Objects for stateful WebSocket connections
  • OrderEnvelope schema for typed messages
  • Broadcast method: broadcast(message, { excludes: [ws] })
  • Message format: { e: event, f: frame, t: type, tg: target, p: payload, a: action }

API PATTERNS:
  • oRPC with Zod validation
  • Spec-first design (routes define specs)
  • requireRoles middleware for RBAC (ADMIN, SYSTEM, MERCHANT, DRIVER, USER)
  • Transaction-wrapped mutations for consistency

STATE MANAGEMENT:
  WEB:
    • TanStack Query for server state
    • React Context for client state
    • No WebSocket integration yet (pattern exists in useOrderUpdates)
  
  MOBILE:
    • BLoC pattern with Cubits
    • StateMapper for type safety
    • GetIt for dependency injection
    • Guard pattern for error handling

═══════════════════════════════════════════════════════════════════════════════

CRITICAL CODE FILES:

Reference Patterns to Follow:
  1. DriverAvailabilityService (287 lines)
     → Use this as template for MerchantAvailabilityService
     → Methods: setOnlineStatus(), isAvailableForOrders(), canBeAssigned()

  2. OrderRoom WebSocket (1123 lines)
     → Shows transaction-wrapped handlers
     → Broadcast pattern
     → Message routing logic
     → Error handling with rollback

  3. Driver Availability Flow
     → Web: apps/web/src/routes/dash/driver/profile.tsx
     → Mobile: apps/mobile/lib/features/driver/presentation/screens/driver_profile_screen.dart
     → These show toggle implementations for reference

═══════════════════════════════════════════════════════════════════════════════

IMPLEMENTATION ROADMAP:

Phase 1: DATABASE & SCHEMA (2-4 hours)
  □ Add fields: isOnline, isTakingOrders, operatingStatus, businessHours*
  □ Add MERCHANT_STATUSES to constants
  □ Update MerchantSchema in packages/schema/src/merchant.ts
  □ Create & test migration with db:push

Phase 2: BUSINESS LOGIC (4-6 hours)
  □ Create merchant-availability-service.ts
  □ Add availability validation to merchant-order-repository.ts
  □ Add handlers for toggle endpoints
  □ Add repository methods for status operations
  □ Write unit tests

Phase 3: WEBSOCKET (6-8 hours)
  □ Create merchant-ws.ts Durable Object
  □ Add /ws/merchant/:id route in ws.ts
  □ Add message handlers (MERCHANT_ONLINE, OFFLINE, etc.)
  □ Integrate auto-reject when merchant goes offline
  □ Test with WebSocket client

Phase 4: WEB UI (4-6 hours)
  □ Add WebSocket integration to merchant provider
  □ Create status toggle component
  □ Create operating hours configuration page
  □ Add status indicator to dashboard
  □ Test in development

Phase 5: MOBILE UI (4-6 hours)
  □ Create merchant_availability_cubit.dart
  □ Implement power button handler
  □ Create availability management screen
  □ Add WebSocket listener for real-time sync
  □ Test on device

Total Estimate: 20-30 hours (approximately 1 week for 1 developer)

═══════════════════════════════════════════════════════════════════════════════

CRITICAL PATTERNS & RULES:

✓ All status changes must use db.transaction() for consistency
✓ Invalidate merchant cache when status changes (CACHE_TTLS used)
✓ Use structured logging with context: log.info({ merchantId }, "[ClassName] action")
✓ Only merchant owner or SYSTEM role can toggle availability
✓ Orders must validate merchant.isOnline before assignment
✓ Use PostGIS for location-based merchant filtering
✓ Broadcast WebSocket events to all connected users
✓ Handle in-flight orders if merchant goes offline (auto-refund)
✓ Make timezone-aware for business hours
✓ Never break existing merchant API endpoints

═══════════════════════════════════════════════════════════════════════════════

INFRASTRUCTURE AVAILABLE:

✅ Transaction support with db.transaction(async (tx) => { ... })
✅ WebSocket with Cloudflare Durable Objects
✅ Broadcast pattern: this.broadcast(message, { excludes: [...] })
✅ Structured logging with log.info/warn/error
✅ Error types: RepositoryError, AuthError, BaseError
✅ RBAC middleware: requireRoles("MERCHANT", "SYSTEM")
✅ Type-safe API generation (Dart client from OpenAPI spec)
✅ Caching with TTLs: CACHE_TTLS["5m"], ["1h"], ["24h"]
✅ PostGIS geospatial queries (distance, radius, nearby)
✅ Drizzle ORM with proper relations & indexes

═══════════════════════════════════════════════════════════════════════════════

RISKS & MITIGATIONS:

Risk: Breaking existing merchant activation (isActive) flow
→ Mitigation: Keep isActive for account status, add new isOnline for availability

Risk: Orders assigned to offline merchants
→ Mitigation: Add validation check before assignment, auto-reject with refund

Risk: Database migration breaking backward compatibility
→ Mitigation: Make new fields nullable, backfill in subsequent migration

Risk: WebSocket broadcast flooding users
→ Mitigation: Use message debouncing, aggregate status changes

Risk: Timezone issues with business hours
→ Mitigation: Store timezone with merchant, validate on both client & server

═══════════════════════════════════════════════════════════════════════════════

NEXT STEPS:

1. Review MERCHANT_AVAILABILITY_ANALYSIS.md for detailed breakdown
2. Check MERCHANT_AVAILABILITY_QUICK_REFERENCE.md for quick lookup
3. Start with Phase 1 (database schema changes)
4. Follow patterns from DriverAvailabilityService
5. Reference OrderRoom WebSocket for real-time implementation
6. Test each phase with existing patterns

═══════════════════════════════════════════════════════════════════════════════

Generated by: Codebase Exploration
Date: 2025-12-07
Status: Complete
Files analyzed: 50+
Total lines documented: 900+
