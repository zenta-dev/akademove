<!-- Generated by Ruler -->


<!-- Source: .ruler/AGENTS.md -->

# Agent Development Guide - AkadeMove

## üéØ Domain Context (Read docs/srs-new.md)
**AkadeMove** is a campus mobility & delivery platform connecting students as users/drivers with campus merchants. **Key differentiators**: driver flexibility (can disable during class), gender-based driver matching, campus-only ecosystem, commission-based model, real-time tracking, leaderboard/badges for gamification.

**Roles**: USER (passenger/customer), DRIVER (student mitra), MERCHANT/TENANT (campus shops), OPERATOR (campus management), ADMIN (platform owner). **Services**: RIDE (transport), DELIVERY (goods/documents), FOOD (campus food delivery). **Core flows**: order matching ‚Üí driver acceptance ‚Üí pickup ‚Üí in-trip ‚Üí completion ‚Üí payment ‚Üí rating/review.

## üèóÔ∏è Architecture
**Monorepo**: Turbo + Bun workspaces. **Server**: Cloudflare Workers (Hono + oRPC + Drizzle ORM + PostgreSQL + PostGIS). **Web**: React 19 + TanStack Router/Query + Shadcn UI. **Mobile**: Flutter + BLoC + GetIt DI. **Packages**: `@repo/schema` (Zod), `@repo/shared` (utils), `@repo/i18n` (translations). **Real-time**: WebSocket + Durable Objects for order tracking, driver location streaming.

## üöÄ Commands
**Lint/Format**: `bun run check` (Biome auto-fix). **Type Check**: `turbo check-types`. **Build All**: `turbo build`. **Dev All**: `bun run dev` (alchemy + i18n). **Dev Server**: `turbo -F server dev` or `bun run dev:server`. **Dev Web**: `turbo -F web dev` or `bun run dev:web`. **Flutter Test (Single)**: `cd apps/mobile && flutter test test/path/to/test_file.dart`. **Flutter Test (All)**: `cd apps/mobile && flutter test`. **DB Push**: `turbo -F server db:push` or `bun run db:push`. **DB Studio**: `bun run db:studio`. **DB Generate Migration**: `turbo -F server db:generate`. **DB Migrate**: `turbo -F server db:migrate`. **DB Seed**: `bun run db:seed`. **DB Reset**: `bun run db:reset`. **Generate Dart API Client**: (1) `bun run dev` (start server, may take time), (2) `make gen` (generates client from OpenAPI spec at `http://localhost:3000/api/spec.json`), (3) `melos generate` (runs build_runner for json_serializable). All commands run from project root.

## üìù Code Style
**Formatting**: Tabs (indentStyle), double quotes (Biome enforced). **Imports**: Auto-organize imports (Biome). Use `@/*` path aliases (e.g., `@/core/services/db`). Import from `@repo/schema`, `@repo/shared`, `@repo/i18n`. **Types**: NEVER use `any` (TypeScript) or `dynamic` (Dart) - use `unknown` instead. NEVER use null assertion operators (`!.` in TypeScript/Dart) - always check for null/undefined explicitly. Enable strict mode. **Naming**: camelCase for TS/JS variables, PascalCase for classes/components, snake_case for Dart/database columns. **File Naming**: kebab-case for all files (e.g., `order-handler.ts`, `order_cubit.dart`).

## üîß TypeScript/Server Patterns

### Route Handlers (`*-handler.ts`)
1. Import spec: `import { FeatureSpec } from "./feature-spec"`
2. Create router: `const { pub, priv } = createORPCRouter(FeatureSpec)`
3. Use middleware: `.use(hasPermission({ resource: ["action"] }))`
4. Always trim input: `trimObjectValues(body)` before processing
5. Wrap mutations in transactions: `context.svc.db.transaction(async (tx) => { ... })`
6. Return structured responses: `{ status: 200, body: { message: "...", data: result } }`

**Example**:
```typescript
export const OrderHandler = priv.router({
  placeOrder: priv.placeOrder
    .use(hasPermission({ order: ["create"] }))
    .handler(async ({ context, input: { body } }) => {
      return await context.svc.db.transaction(async (tx) => {
        const data = trimObjectValues(body);
        const result = await context.repo.order.placeOrder({ ...data, userId: context.user.id }, { tx });
        return { status: 200, body: { message: "Order placed", data: result } };
      });
    }),
});
```

### Repository Layer (`*-repository.ts`)
1. Extend `BaseRepository` from `@/core/base`
2. Accept `opts?: PartialWithTx` or `opts: WithTx` for all DB methods
3. Use `opts.tx ?? this.db` for queries to support transactions
4. Generate IDs with `v7()` from `uuid`
5. Handle decimals with `toNumberSafe()` / `toStringNumberSafe()` from `@/utils`
6. Throw errors: `throw new RepositoryError("message", { code: "BAD_REQUEST" })`
7. Use cache with fallback: `await this.getCache(key, { fallback: async () => { ... } })`
8. Set cache with TTL: `await this.setCache(key, value, { expirationTtl: CACHE_TTLS["1h"] })`
9. Log with context: `log.info({ userId, orderId }, "[RepoName] Action description")`
10. **Geospatial queries**: Use PostGIS functions for distance/radius calculations (driver matching)

**Example**:
```typescript
export class OrderRepository extends BaseRepository {
  async get(id: string, opts?: WithTx): Promise<Order> {
    try {
      const fallback = async () => {
        const res = await (opts?.tx ?? this.db).query.order.findFirst({
          where: (f, op) => op.eq(f.id, id),
        });
        if (!res) throw new RepositoryError("Order not found", { code: "NOT_FOUND" });
        await this.setCache(id, res, { expirationTtl: CACHE_TTLS["1h"] });
        return OrderRepository.composeEntity(res);
      };
      return await this.getCache(id, { fallback });
    } catch (error) {
      throw this.handleError(error, "get by id");
    }
  }
}
```

### Error Handling
1. Use try-catch in all async methods
2. Log errors with context: `log.error({ error, userId }, "[ClassName] Operation failed")`
3. Re-throw to trigger transaction rollback
4. Use typed errors: `RepositoryError`, `BaseError`, `AuthError`
5. Include error codes: `{ code: "BAD_REQUEST" | "NOT_FOUND" | "UNAUTHORIZED" | "FORBIDDEN" | "INTERNAL_SERVER_ERROR" }`

### Database & Transactions
1. All write operations MUST be in transactions: `context.svc.db.transaction(async (tx) => { ... })`
2. Pass `{ tx }` to all repository calls within a transaction
3. Use Drizzle ORM query builder: `tx.query.table.findFirst({ ... })`
4. Index commonly queried fields (see `src/core/tables/*.ts`)
5. Use composite indexes for multi-column filters (e.g., `userId + status + createdAt`)
6. Add text pattern indexes for ILIKE searches: `index().on(column.op("text_pattern_ops"))`
7. **PostGIS indexes**: Add spatial indexes for location columns used in radius queries

### WebSocket Real-time (`*-ws.ts`)
1. Use Durable Objects for stateful WebSocket connections
2. Implement heartbeat/ping-pong for connection health
3. Broadcast order status changes to subscribed clients
4. Stream driver location updates during active trips
5. Handle reconnection gracefully with state recovery

## ‚öõÔ∏è React/Web Patterns

### Components
1. Use Shadcn UI components from `@/components/ui/*`
2. Form validation: `zodResolver` from `@hookform/resolvers/zod`
3. Use `react-hook-form` for all forms
4. Toast notifications: `import { toast } from "sonner"`
5. **Maps**: Use `@vis.gl/react-google-maps` for location display/selection

### Data Fetching & Mutations
1. Import client: `import { orpcClient, orpcQuery, queryClient } from "@/lib/orpc"`
2. Queries: Use TanStack Query hooks directly with `orpcClient`
3. Mutations: Use `orpcQuery.feature.method.mutationOptions({ ... })`
4. ALWAYS invalidate queries after mutations: `queryClient.invalidateQueries({ queryKey: [...] })`
5. **Real-time**: Use WebSocket hooks for live order/location updates

**Example**:
```typescript
const mutation = useMutation(
  orpcQuery.order.placeOrder.mutationOptions({
    mutationFn: async (data) => {
      const result = await orpcClient.order.placeOrder(data);
      if (result.status !== 200) throw new Error(result.body.message);
      return result;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["orders"] });
      toast.success("Order placed successfully");
    },
  })
);
```

### Routing
1. Use TanStack Router file-based routing in `src/routes/`
2. Route files: `route.tsx` for route components
3. Loaders for data fetching: `export const Route = createFileRoute("/path")({ loader: async () => { ... } })`
4. **Role-based routes**: Protect routes by user role (ADMIN/OPERATOR/MERCHANT/DRIVER/USER)

## üì± Flutter/Dart Patterns

### Architecture
1. Feature-based structure: `lib/features/{feature}/*`
2. Each feature has: `cubit`, `repository`, `view`, `widgets`
3. Use BLoC pattern with `BaseCubit<State>`
4. Dependency injection with GetIt: `sl<Service>()`
5. **Location**: Use `geolocator` for GPS, `google_maps_flutter` for map display
6. **Real-time**: Use `web_socket_channel` for order/location updates

### Cubits (State Management)
1. Extend `BaseCubit<FeatureState>` from `@/core/*`
2. Define sealed states: `initial`, `loading`, `success(data)`, `failure(error)`
3. Wrap API calls in `guard()` for error handling
4. Log errors: `logger.e("message", error: e, stackTrace: st)`
5. Use `emit()` to update state
6. NEVER use `dynamic` - use proper types or `Object?`

**Example**:
```dart
class OrderCubit extends BaseCubit<OrderState> {
  OrderCubit({required this.orderRepository}) : super(OrderState.initial());
  
  final OrderRepository orderRepository;
  
  Future<void> placeOrder(PlaceOrderRequest request) async {
    emit(OrderState.loading());
    await guard(
      () async {
        final order = await orderRepository.placeOrder(request);
        emit(OrderState.success(order));
      },
      onError: (e, st) {
        logger.e('Failed to place order', error: e, stackTrace: st);
        emit(OrderState.failure(e.toString()));
      },
    );
  }
}
```

### Testing
1. Place tests in `test/` mirroring `lib/` structure
2. Use `bloc_test` for cubit testing
3. Use `mocktail` for mocking dependencies
4. Run single test: `cd apps/mobile && flutter test test/features/order/cubit/order_cubit_test.dart`
5. Run all tests: `cd apps/mobile && flutter test`

## üì¶ Schema & Validation

### Zod Schemas
1. Define in `packages/schema/src/*.ts`
2. Export schema + inferred type: `export const Schema = z.object({ ... }); export type Type = z.infer<typeof Schema>;`
3. Create variants: `InsertSchema = Schema.omit({ id: true, createdAt: true, updatedAt: true })`
4. Update schemas: `UpdateSchema = InsertSchema.partial()`
5. Use in handlers: Zod validates automatically via oRPC spec
6. **Domain enums**: Use `CONSTANTS` from `@repo/schema/constants` (ORDER_TYPES, ORDER_STATUSES, USER_ROLES, etc.)

**Example**:
```typescript
export const OrderSchema = z.object({
  id: z.string().uuid(),
  userId: z.string(),
  driverId: z.string().nullable(),
  type: OrderTypeSchema, // "RIDE" | "DELIVERY" | "FOOD"
  status: OrderStatusSchema, // "REQUESTED" | "MATCHING" | "ACCEPTED" | ...
  genderPreference: z.enum(["SAME", "ANY"]).optional(),
  totalPrice: z.coerce.number(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

export const InsertOrderSchema = OrderSchema.omit({ id: true, createdAt: true, updatedAt: true });
export const UpdateOrderSchema = InsertOrderSchema.partial();
```

## üéØ Best Practices

### Performance
1. Cache frequently accessed data with appropriate TTL (`CACHE_TTLS["5m"]`, `["1h"]`, `["24h"]`)
2. Use database indexes for filtered/sorted columns (status, userId, driverId, createdAt)
3. Batch database queries with `Promise.all()`
4. Use cursor pagination for large lists (order history, leaderboard)
5. **Geospatial optimization**: Use PostGIS spatial indexes for driver matching queries

### Security
1. Always validate input with Zod schemas
2. Use `trimObjectValues()` to sanitize string inputs
3. Check permissions with `hasPermission()` middleware (RBAC: admin/operator/merchant/driver/user)
4. Never expose sensitive data in API responses (phone numbers masked in chat)
5. Use environment variables for secrets (never commit `.env`)
6. **Driver verification**: Require KTM/SIM upload and approval before activation

### Logging
1. Use structured logging: `log.info({ userId, orderId }, "Action description")`
2. Log levels: `log.debug()`, `log.info()`, `log.warn()`, `log.error()`
3. Include error context: `log.error({ error, userId }, "Failed to ...")`
4. **Audit trail**: Log all operator actions (tariff changes, promo creation, user suspensions)

### Code Organization
1. Keep handlers thin - business logic in repositories
2. Reuse code via shared packages (`@repo/schema`, `@repo/shared`, `@repo/i18n`)
3. Feature-based folder structure (group by feature, not by type)
4. Co-locate related files (handler, repository, spec, ws in same feature folder)
5. **Domain alignment**: Feature folders match SRS domains (order, driver, merchant, wallet, etc.)

## üóÑÔ∏è Database Patterns

### Migrations
1. Generate migration: `bun run db:generate` (after schema changes)
2. Review generated SQL in `apps/server/drizzle/migrations/*.sql`
3. Apply migration: `bun run db:push`
4. Never edit migrations manually - modify table schemas in `src/core/tables/*.ts`

### Table Definitions
1. Define in `apps/server/src/core/tables/*.ts`
2. Use `pgTable("table_name", { ... }, (t) => [indexes])`
3. Add indexes for: foreign keys, status columns, commonly filtered/sorted columns
4. Use composite indexes for multi-column queries: `index().on(col1, col2)`
5. Use text pattern indexes for text searches: `index().on(col.op("text_pattern_ops"))`
6. **PostGIS columns**: Use `geometry(Point, 4326)` for location storage with spatial indexes

## üéÆ Domain-Specific Rules

### Order Matching Logic
1. **Driver radius**: Find available drivers within configurable km radius of pickup location
2. **Gender preference**: Filter drivers by gender if user requests "SAME" gender
3. **Priority**: Use leaderboard ranking and badge levels for driver prioritization
4. **Auto-accept timeout**: Cancel matching if no driver accepts within configured duration
5. **Schedule awareness**: Exclude drivers who have marked themselves offline due to class schedule

### Commission Calculation
1. **Driver commission**: Deduct platform percentage from order total
2. **Merchant commission**: Apply commission to food orders
3. **Store in transaction**: Log all commission deductions in `transaction` table
4. **Operator configuration**: Commission rates set by OPERATOR role via configuration API

### Rating & Review System
1. **Two-way rating**: Both driver and user rate each other after order completion
2. **Required for completion**: Order not fully complete until ratings submitted
3. **Impact on matching**: Low-rated drivers/users deprioritized in matching
4. **Categories**: Rate by cleanliness, courtesy, safety, etc. (see `REVIEW_CATEGORIES`)

### Wallet & Payment
1. **Top-up**: Users add balance via QRIS/bank transfer (Midtrans)
2. **Auto-deduct**: Order cost deducted from wallet on order placement
3. **Refund**: Auto-refund if order cancelled by system/driver
4. **Driver earnings**: Transfer to driver wallet on order completion (minus commission)
5. **Withdrawal**: Drivers can withdraw to bank account (see `BANK_PROVIDERS`)

### Order State Machine
**States**: `REQUESTED ‚Üí MATCHING ‚Üí ACCEPTED ‚Üí ARRIVING ‚Üí IN_TRIP ‚Üí COMPLETED/CANCELLED`
- **REQUESTED**: User created order, waiting for matching
- **MATCHING**: System searching for available driver
- **ACCEPTED**: Driver accepted, navigating to pickup
- **ARRIVING**: Driver near pickup location
- **IN_TRIP**: Order in progress (pickup complete)
- **COMPLETED**: Trip finished, awaiting rating
- **CANCELLED**: Cancelled by user/driver/system

## üß™ Testing Guidelines
**Server**: Add tests when implementing complex business logic (matching algorithm, commission calculation, distance pricing). **Web**: Focus on integration tests for critical flows (order placement, merchant order management, operator configuration). **Mobile**: Test cubits with `bloc_test`, mock repositories with `mocktail`. **Coverage**: Aim for >70% on critical business logic.

## üîÑ Git Workflow
1. Create feature branch: `git checkout -b feature/description`
2. Commit with conventional commits: `feat:`, `fix:`, `chore:`, etc.
3. Pre-commit hook runs `lint-staged` (biome check + auto-fix) automatically
4. Keep commits focused and atomic

## üìö Key Files
- **Server Entry**: `apps/server/src/index.ts`
- **Web Entry**: `apps/web/src/main.tsx`
- **Mobile Entry**: `apps/mobile/lib/main.dart`
- **Schemas**: `packages/schema/src/*.ts` (order.ts, driver.ts, merchant.ts, user.ts, wallet.ts, etc.)
- **Shared Utils**: `packages/shared/src/*.ts`
- **DB Tables**: `apps/server/src/core/tables/*.ts`
- **Constants**: `packages/schema/src/constants.ts` (ORDER_TYPES, ORDER_STATUSES, USER_ROLES, etc.)
- **SRS Document**: `docs/srs-new.md` (business requirements and domain rules)

## ‚ö†Ô∏è Common Pitfalls
1. ‚ùå Forgetting `db.transaction()` for write operations
2. ‚ùå Not passing `{ tx }` to repository methods inside transactions
3. ‚ùå Using `any`/`dynamic` types instead of `unknown`
4. ‚ùå Using null assertion operators (`!.`, `!`) instead of proper null checks
5. ‚ùå Forgetting to invalidate queries after mutations
6. ‚ùå Not handling errors with try-catch
7. ‚ùå Missing cache invalidation after updates
8. ‚ùå Not logging errors with context
9. ‚ùå Forgetting to trim input values with `trimObjectValues()`
10. ‚ùå Not using `toNumberSafe()`/`toStringNumberSafe()` for decimals
11. ‚ùå Missing indexes on filtered/sorted database columns
12. ‚ùå Not respecting gender preference in driver matching
13. ‚ùå Forgetting to check driver availability/schedule before assignment
14. ‚ùå Not calculating commission correctly on order completion
15. ‚ùå Missing WebSocket updates for real-time order status changes

## üö® Critical Rules
- **NEVER** use `any` (TS) or `dynamic` (Dart)
- **NEVER** use null assertion operators (`!.`, `!`, `as Type!`) - always check for null/undefined explicitly
- **ALWAYS** wrap multi-step mutations in `db.transaction()`
- **ALWAYS** invalidate queries after mutations
- **ALWAYS** validate input with Zod schemas
- **ALWAYS** handle errors with try-catch + logging
- **ALWAYS** use structured logging with context
- **ALWAYS** pass `opts?: PartialWithTx` to repository methods
- **ALWAYS** use `v7()` for generating UUIDs
- **ALWAYS** check for null/undefined before accessing properties (use `?.`, `??`, conditionals)
- **ALWAYS** respect user gender preferences in driver matching
- **ALWAYS** verify driver is online/available before assignment
- **ALWAYS** calculate and record commission on order completion
- **ALWAYS** emit WebSocket events for order status changes
- **ALWAYS** use PostGIS for geospatial queries (distance calculations, radius searches)
