import "@cloudflare/workers-types";

import { randomBytes } from "node:crypto";
import { readFile } from "node:fs/promises";
import { join } from "node:path";
import * as readline from "node:readline";
import { faker } from "@faker-js/faker";
import type { InsertBadge } from "@repo/schema/badge";
import { CONSTANTS } from "@repo/schema/constants";
import type { InsertMerchant } from "@repo/schema/merchant";
import type { InsertUser } from "@repo/schema/user";
import { eq, inArray, sql } from "drizzle-orm";
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import { v7 } from "uuid";
import { S3StorageService } from "@/core/services/storage";
import {
	configuration,
	configurationAuditLog,
} from "@/core/tables/configuration";
import { driver } from "@/core/tables/driver";
import { merchant } from "@/core/tables/merchant";
import { order } from "@/core/tables/order";
import { PasswordManager } from "@/utils/password";
import { tables } from "./tables";

// Note: Additional table imports for future comprehensive seeding can be added here

// Seeding options type
type SeedOptions = {
	mode: "all" | "base" | "custom";
	seeders: Set<string>;
};

async function promptSeedingOptions(): Promise<SeedOptions> {
	const rl = readline.createInterface({
		input: process.stdin,
		output: process.stdout,
	});

	const question = (prompt: string): Promise<string> =>
		new Promise((resolve) => rl.question(prompt, resolve));

	console.log("\nüìã Seeding Options:");
	console.log(
		"1. All - Seed everything (users, badges, merchants, drivers, orders, etc.)",
	);
	console.log("2. Base - Seed only test users and badges");
	console.log("3. Custom - Pick specific seeders to run");

	const choice = await question("\nSelect option (1-3): ");

	if (choice === "1") {
		rl.close();
		return { mode: "all", seeders: new Set() };
	}

	if (choice === "2") {
		rl.close();
		return {
			mode: "base",
			seeders: new Set(["users", "badges", "userBadges", "configurations"]),
		};
	}

	if (choice === "3") {
		console.log("\nüì¶ Available seeders:");
		console.log("1. users - Test users and random users");
		console.log("2. badges - Badge definitions");
		console.log("3. userBadges - Assign badges to test users");
		console.log("4. configurations - System configurations");
		console.log("5. merchants - Merchant profiles");
		console.log("6. drivers - Driver profiles");
		console.log("7. orders - Sample orders");
		console.log("8. driverQuiz - Driver quiz questions and answers");
		console.log("9. coupons - Coupon definitions");
		console.log("10. broadcasts - Broadcast messages");
		console.log("11. reviews - Order reviews");
		console.log("12. transactions - Transactions and payments");
		console.log("13. leaderboards - Leaderboard rankings");
		console.log("14. notifications - FCM tokens and notifications");
		console.log("15. supportChat - Support tickets and messages");
		console.log("16. orderChat - Order chat messages");
		console.log(
			"17. miscellaneous - Reports, contacts, newsletters, emergencies, account deletions",
		);

		const selections = await question(
			"\nEnter seeder numbers separated by commas (e.g., 1,2,3): ",
		);

		const seederMap: Record<string, string> = {
			"1": "users",
			"2": "badges",
			"3": "userBadges",
			"4": "configurations",
			"5": "merchants",
			"6": "drivers",
			"7": "orders",
			"8": "driverQuiz",
			"9": "coupons",
			"10": "broadcasts",
			"11": "reviews",
			"12": "transactions",
			"13": "leaderboards",
			"14": "notifications",
			"15": "supportChat",
			"16": "orderChat",
			"17": "miscellaneous",
		};

		const selectedSeeders = new Set(
			selections
				.split(",")
				.map((s) => s.trim())
				.filter((s) => seederMap[s])
				.map((s) => seederMap[s]),
		);

		rl.close();
		return { mode: "custom", seeders: selectedSeeders };
	}

	rl.close();
	console.log("‚ùå Invalid option selected.");
	process.exit(0);
}

async function confirmExecution() {
	if (process.env.NODE_ENV === "production") {
		console.error("‚ùå Seeding is blocked in production!");
		process.exit(1);
	}

	const rl = readline.createInterface({
		input: process.stdin,
		output: process.stdout,
	});

	const confirmation = await new Promise<string>((resolve) =>
		rl.question(
			"\n‚ö†Ô∏è  WARNING: This will insert seed data into your database.\n" +
				"Type 'SEED' to continue: ",
			resolve,
		),
	);

	rl.close();

	if (confirmation !== "SEED") {
		console.log("‚ùå Operation cancelled.");
		process.exit(0);
	}
}

console.log(`DB URL: ${process.env.DATABASE_URL}`);

const client = postgres(process.env.DATABASE_URL || "");
const db = drizzle({ client });
const storage = new S3StorageService({
	endpoint: process.env.S3_ENDPOINT || "",
	region: process.env.S3_REGION || "",
	accessKeyId: process.env.S3_ACCESS_KEY_ID || "",
	secretAccessKey: process.env.S3_SECRET_ACCESS_KEY || "",
	publicUrl: process.env.S3_PUBLIC_URL || "",
});

function generateId(): string {
	return randomBytes(16).toString("hex");
}

async function seedUser(baseOnly = false) {
	const pw = new PasswordManager();

	const FIXED_USERS: Omit<InsertUser, "confirmPassword" | "userBadges">[] = [
		{
			name: "Test Admin 1",
			email: "test-admin-1@akademove.com",
			role: "ADMIN",
			password: "Ch@ngEThi5",
			phone: { countryCode: "ID", number: 8573230851 },
		},
		{
			name: "Test Operator 1",
			email: "test-operator-1@akademove.com",
			role: "OPERATOR",
			password: "Ch@ngEThi5",
			phone: { countryCode: "ID", number: 8573230852 },
		},
		{
			name: "Test Merchant 1",
			email: "test-merchant-1@akademove.com",
			role: "MERCHANT",
			password: "Ch@ngEThi5",
			phone: { countryCode: "ID", number: 8573230853 },
		},
		{
			name: "Test Driver 1",
			email: "test-driver-1@akademove.com",
			role: "DRIVER",
			password: "Ch@ngEThi5",
			phone: { countryCode: "ID", number: 8573230854 },
			gender: "MALE",
		},
		{
			name: "Test User 1",
			email: "test-user-1@akademove.com",
			role: "USER",
			password: "Ch@ngEThi5",
			phone: { countryCode: "ID", number: 8573230855 },
			gender: "MALE",
		},
	];

	const RANDOM_USERS = baseOnly
		? []
		: Array.from({ length: 500 }).map(
				() =>
					({
						name: faker.person.fullName(),
						email: faker.internet.email().toLowerCase(),
						role: faker.helpers.arrayElement(["USER", "DRIVER", "MERCHANT"]),
						password: "Ch@ngEThi5",
						phone: {
							countryCode: "ID",
							number: Number(
								faker.phone.number({ style: "human" }).replace(/\D/g, ""),
							),
						},
						gender: faker.helpers.arrayElement(["MALE", "FEMALE"]),
					}) as const,
			);

	const USERS = baseOnly
		? FIXED_USERS
		: [
				...new Map(
					[...FIXED_USERS, ...RANDOM_USERS].map((u) => [u.email, u]),
				).values(),
			];

	console.log("üîç Checking existing users...");

	const existing = await db
		.select({ email: tables.user.email, phone: tables.user.phone })
		.from(tables.user)
		.where(
			inArray(
				tables.user.email,
				USERS.map((u) => u.email),
			),
		);

	const existingEmails = new Set(existing.map((u) => u.email));
	const existingPhones = new Set(existing.map((u) => JSON.stringify(u.phone)));

	const missingUsers = USERS.filter(
		(u) =>
			!existingEmails.has(u.email) &&
			!existingPhones.has(JSON.stringify(u.phone)),
	);

	if (missingUsers.length === 0) {
		console.log("‚úÖ All users already exist.");
		return;
	}

	console.log(`üå± Seeding ${missingUsers.length} new users...`);

	try {
		const hashedPassword = pw.hash("Ch@ngEThi5");

		// Batch insert users and accounts
		const userInsertData = missingUsers.map((user) => ({
			...user,
			id: generateId(),
		}));

		const insertedUsers = await db
			.insert(tables.user)
			.values(userInsertData)
			.returning({ id: tables.user.id });

		const accountInsertData = insertedUsers.map((user) => ({
			id: generateId(),
			accountId: generateId(),
			userId: user.id,
			providerId: "credentials",
			password: hashedPassword,
		}));
		const walletInsertData = insertedUsers.map((user) => ({
			id: v7(),
			userId: user.id,
			balance: "0",
		}));

		await Promise.all([
			db.insert(tables.account).values(accountInsertData),
			db.insert(tables.wallet).values(walletInsertData),
		]);

		console.log("‚úÖ User seeding complete.");
	} catch (err) {
		console.error("‚ùå Failed to seed users:", err);
		throw err;
	}
}

export async function seedConfigurations() {
	console.log("üîß Seeding Configurations...");

	// Use a transaction for consistency
	await db.transaction(async (tx) => {
		const [admin] = await tx
			.select()
			.from(tables.user)
			.where(eq(tables.user.email, "test-admin-1@akademove.com"))
			.limit(1);

		if (!admin) {
			console.warn("‚ö†Ô∏è Admin user not found. Skipping configurations.");
			return;
		}

		const now = new Date();

		const CONFIGS = [
			{
				key: "ride-service-pricing",
				name: "Ride Pricing",
				value: {
					baseFare: 5_000,
					perKmRate: 2_500,
					minimumFare: 10_000,
					platformFeeRate: 0.02,
					taxRate: 0.11,
				},
				description: "Ride service pricing structure",
				updatedById: admin.id,
				createdAt: now,
				updatedAt: now,
			},
			{
				key: "delivery-service-pricing",
				name: "Delivery Pricing",
				value: {
					baseFare: 8_000,
					perKmRate: 3_000,
					minimumFare: 12_000,
					perKg: 2_000,
					platformFeeRate: 0.02,
					taxRate: 0.11,
				},
				description: "Delivery pricing per km/kg",
				updatedById: admin.id,
				createdAt: now,
				updatedAt: now,
			},
			{
				key: "food-service-pricing",
				name: "Food Pricing",
				value: {
					baseFare: 8_000,
					perKmRate: 2_500,
					minimumFare: 10_000,
					platformFeeRate: 0.02,
					taxRate: 0.11,
				},
				description: "Food delivery pricing",
				updatedById: admin.id,
				createdAt: now,
				updatedAt: now,
			},
			{
				key: "commission-rates",
				name: "Commission Rates",
				value: {
					rideCommissionRate: 0.15,
					deliveryCommissionRate: 0.15,
					foodCommissionRate: 0.2,
					merchantCommissionRate: 0.1,
				},
				description:
					"Platform commission rates for different order types (SRS 8.4)",
				updatedById: admin.id,
				createdAt: now,
				updatedAt: now,
			},
		];

		await tx
			.insert(configuration)
			.values(CONFIGS)
			.onConflictDoUpdate({
				target: configuration.key,
				set: {
					name: sql`excluded.name`,
					value: sql`excluded.value`,
					description: sql`excluded.description`,
					updatedById: sql`excluded.updated_by_id`,
					updatedAt: sql`excluded.updated_at`,
				},
			});

		const existingConfigs = await tx
			.select({
				key: configuration.key,
				value: configuration.value,
			})
			.from(configuration)
			.where(
				sql`${configuration.key} IN (${sql.join(
					CONFIGS.map((c) => sql`${c.key}`),
					sql`, `,
				)})`,
			);

		const existingMap = Object.fromEntries(
			existingConfigs.map((c) => [c.key, c.value]),
		);

		const auditLogs = CONFIGS.map((conf) => {
			const previousValue = existingMap[conf.key];
			const operation = previousValue ? "UPDATE" : "INSERT";
			return {
				tableName: "configurations",
				recordId: conf.key,
				operation,
				oldData: previousValue ?? null,
				newData: conf.value,
				updatedById: admin.id,
				updatedAt: now,
			} as const;
		});

		await tx.insert(configurationAuditLog).values(auditLogs);

		console.log("‚úÖ Configurations seeded/updated successfully.");
	});
}

async function seedMerchants() {
	console.log("üè™ Seeding Merchants...");

	const users = await db
		.select()
		.from(tables.user)
		.where(eq(tables.user.role, "MERCHANT"));

	if (users.length === 0) {
		console.warn("‚ö†Ô∏è No users with role 'merchant' found.");
		return;
	}

	// Check existing merchants to avoid duplicates
	const existingMerchants = await db
		.select({ userId: merchant.userId })
		.from(merchant);

	const existingUserIds = new Set(existingMerchants.map((m) => m.userId));
	const availableUsers = users.filter((u) => !existingUserIds.has(u.id));

	if (availableUsers.length === 0) {
		console.log("‚úÖ All merchant users already have merchants.");
		return;
	}

	const merchantsToCreate = Math.min(50, availableUsers.length);
	const merchants = Array.from({ length: merchantsToCreate }).map((_, i) => {
		const user = availableUsers[i];
		const bankProvider = faker.helpers.arrayElement(CONSTANTS.BANK_PROVIDERS);
		const category = faker.helpers.arrayElement(CONSTANTS.MERCHANT_CATEGORIES);

		return {
			id: v7(),
			userId: user.id,
			name: faker.company.name(),
			email: user.email,
			phone: user.phone,
			address: faker.location.streetAddress(),
			category,
			location: {
				y: faker.location.latitude(),
				x: faker.location.longitude(),
			},
			bank: {
				provider: bankProvider,
				number: faker.number.int({ min: 1_000_000, max: 9_999_999 }),
			},
		} satisfies InsertMerchant & { userId: string; id: string };
	});

	await db.insert(merchant).values(merchants);
	console.log(`‚úÖ Inserted ${merchants.length} merchants.`);
}

const BASE_LAT = -6.2221877;
const BASE_LNG = 106.8724405;
const OFFSET_METERS = 5000;

function randomOffsetLatLng(
	baseLat: number,
	baseLng: number,
	radiusMeters: number,
) {
	const radiusDeg = radiusMeters / 111000;
	const u = Math.random();
	const v = Math.random();
	const w = radiusDeg * Math.sqrt(u);
	const t = 2 * Math.PI * v;
	const dy = w * Math.sin(t);
	const dx = w * Math.cos(t);
	const newLat = baseLat + dy;
	const newLng = baseLng + dx / Math.cos(baseLat * (Math.PI / 180));
	return { lat: newLat, lng: newLng };
}

async function seedDrivers() {
	console.log("üöó Seeding Drivers near location...");

	const users = await db
		.select()
		.from(tables.user)
		.where(eq(tables.user.role, "DRIVER"));

	if (users.length === 0) {
		console.warn("‚ö†Ô∏è No users with role 'driver' found.");
		return;
	}

	// Check existing drivers to avoid duplicates
	const existingDrivers = await db
		.select({ userId: driver.userId })
		.from(driver);

	const existingUserIds = new Set(existingDrivers.map((d) => d.userId));
	const availableUsers = users.filter((u) => !existingUserIds.has(u.id));

	if (availableUsers.length === 0) {
		console.log("‚úÖ All driver users already have driver profiles.");
		return;
	}

	const drivers = availableUsers.map((user) => {
		const bankProvider = faker.helpers.arrayElement(CONSTANTS.BANK_PROVIDERS);
		const { lat, lng } = randomOffsetLatLng(BASE_LAT, BASE_LNG, OFFSET_METERS);

		return {
			id: v7(),
			userId: user.id,
			studentId: faker.number.int({ min: 2_000_000, max: 9_999_999 }),
			licensePlate: faker.string.alphanumeric(8).toUpperCase(),
			status: faker.helpers.arrayElement(CONSTANTS.DRIVER_STATUSES),
			rating: Number.parseFloat(
				faker.number.float({ min: 3.5, max: 5 }).toFixed(1),
			),
			isOnline: faker.datatype.boolean(),
			currentLocation: sql`ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326)`,
			lastLocationUpdate: faker.date.recent({ days: 10 }),
			bank: {
				provider: bankProvider,
				number: faker.number.int({ min: 1_000_000, max: 9_999_999 }),
			},
			studentCard: "DL-0199ef0c-7758-7508-b906-4a706df54709.jpg",
			driverLicense: "DL-0199ef0c-7758-7508-b906-4a706df54709.jpg",
			vehicleCertificate: "DL-0199ef0c-7758-7508-b906-4a706df54709.jpg",
			createdAt: new Date(),
			updatedAt: new Date(),
		};
	});

	await db.insert(driver).values(drivers);
	console.log(
		`‚úÖ Inserted ${drivers.length} drivers near (${BASE_LAT}, ${BASE_LNG}).`,
	);
}

async function seedOrders() {
	console.log("üì¶ Seeding Orders...");

	const users = await db
		.select({ id: tables.user.id })
		.from(tables.user)
		.where(eq(tables.user.role, "USER"));

	const drivers = await db.select({ id: driver.id }).from(driver);
	const merchants = await db.select({ id: merchant.id }).from(merchant);

	if (!users.length) {
		console.warn("‚ö†Ô∏è No user accounts found.");
		return;
	}

	const maybePick = <T extends { id: string }>(arr: T[]) =>
		arr.length > 0 && faker.datatype.boolean()
			? faker.helpers.arrayElement(arr).id
			: null;

	const orders = Array.from({ length: 50 }).map(() => {
		const u = faker.helpers.arrayElement(users);
		const distanceKm = Number(
			faker.number.float({ min: 1, max: 50 }).toFixed(2),
		);
		const baseFare = faker.number.int({
			min: 5000,
			max: 15000,
			multipleOf: 500,
		});
		const perKmRate = faker.number.int({
			min: 2000,
			max: 5000,
			multipleOf: 100,
		});
		const totalPrice = baseFare + Math.round(distanceKm * perKmRate);

		const pickup = {
			x: Number(faker.location.longitude({ min: 106.7, max: 106.9 })),
			y: Number(faker.location.latitude({ min: -6.3, max: -6.1 })),
		};
		const dropoff = {
			x: Number(faker.location.longitude({ min: 106.7, max: 106.9 })),
			y: Number(faker.location.latitude({ min: -6.3, max: -6.1 })),
		};

		return {
			id: v7(),
			userId: u.id,
			driverId: maybePick(drivers),
			merchantId: maybePick(merchants),
			type: faker.helpers.arrayElement(CONSTANTS.ORDER_TYPES),
			status: faker.helpers.arrayElement(CONSTANTS.ORDER_STATUSES),
			pickupLocation: sql`ST_SetSRID(ST_MakePoint(${pickup.x}, ${pickup.y}), 4326)`,
			dropoffLocation: sql`ST_SetSRID(ST_MakePoint(${dropoff.x}, ${dropoff.y}), 4326)`,
			distanceKm,
			basePrice: `${baseFare}`,
			totalPrice: `${totalPrice}`,
			createdAt: faker.date.recent({ days: 30 }),
		};
	});

	await db.insert(order).values(orders);
	console.log(`‚úÖ Inserted ${orders.length} orders.`);
}

// Additional seeders can be implemented here for complex tables:
// - driver_quiz_questions, driver_quiz_answers
// - coupons, coupon_usages
// - broadcasts
// - reviews, transactions, payments
// - leaderboards, notifications
// - support_tickets, support_chat_messages, order_chat_messages
// - contacts, newsletters, reports, emergencies, account_deletions
//
// These require careful schema alignment and are omitted for now.

async function main() {
	try {
		await confirmExecution();

		const options = await promptSeedingOptions();

		console.log("\nüå± Starting database seeding...\n");

		// Determine which seeders to run
		const shouldRun = (seeder: string) => {
			if (options.mode === "all") return true;
			return options.seeders.has(seeder);
		};
		{
			question:
				"What should you do if a passenger requests a different gender driver?",
			type: "MULTIPLE_CHOICE" as const,
			category: "SAFETY" as const,
			options: [
				{
					id: v7(),
					text: "Refuse the request and continue with the ride",
					isCorrect: false,
				},
				{
					id: v7(),
					text: "Contact support to handle the request",
					isCorrect: true,
				},
				{ id: v7(), text: "Cancel the order immediately", isCorrect: false },
				{ id: v7(), text: "Ignore the request and proceed", isCorrect: false },
			],
			explanation:
				"Gender preference requests should be handled by the platform support team.",
			points: 10,
			isActive: true,
			displayOrder: 1,
		},
		{
			question: "What is the maximum speed limit in campus areas?",
			type: "MULTIPLE_CHOICE" as const,
			category: "SAFETY" as const,
			options: [
				{ id: v7(), text: "30 km/h", isCorrect: true },
				{ id: v7(), text: "50 km/h", isCorrect: false },
				{ id: v7(), text: "40 km/h", isCorrect: false },
				{ id: v7(), text: "60 km/h", isCorrect: false },
			],
			explanation:
				"Campus areas have strict speed limits for pedestrian safety.",
			points: 15,
			isActive: true,
			displayOrder: 2,
		},
		{
			question: "How should you handle emergency situations?",
			type: "MULTIPLE_CHOICE" as const,
			category: "EMERGENCY_PROCEDURES" as const,
			options: [
				{ id: v7(), text: "Continue driving normally", isCorrect: false },
				{
					id: v7(),
					text: "Contact emergency services and platform support",
					isCorrect: true,
				},
				{
					id: v7(),
					text: "Handle it yourself without reporting",
					isCorrect: false,
				},
				{ id: v7(), text: "Cancel all orders immediately", isCorrect: false },
			],
			explanation:
				"Emergency situations require immediate professional assistance and platform coordination.",
			points: 20,
			isActive: true,
			displayOrder: 3,
		},
	];

	const questionData = questions.map((q) => ({
		id: v7(),
		question: q.question,
		type: q.type,
		category: q.category,
		options: q.options,
		explanation: q.explanation,
		points: q.points,
		isActive: q.isActive,
		displayOrder: q.displayOrder,
		createdAt: new Date(),
		updatedAt: new Date(),
	}));

	await db.insert(driverQuizQuestion).values(questionData);
	console.log(`‚úÖ Inserted ${questionData.length} driver quiz questions.`);
}

async function seedDriverQuizAnswers() {
	console.log("üìù Seeding Driver Quiz Answers...");

	const drivers = await db.select({ id: driver.userId }).from(driver);
	const questions = await db
		.select({ id: driverQuizQuestion.id })
		.from(driverQuizQuestion);

	if (drivers.length === 0 || questions.length === 0) {
		console.warn("‚ö†Ô∏è No drivers or questions found. Skipping quiz answers.");
		return;
	}

	const answers = drivers.map((driver) => {
		const isCompleted = faker.datatype.boolean();
		const correctAnswers = faker.number.int({ min: 2, max: questions.length });
		const totalPoints = questions
			.slice(0, correctAnswers)
			.reduce((sum, q) => sum + 10, 0);
		const scorePercentage = Math.round(
			(correctAnswers / questions.length) * 100,
		);

		// Generate answers array
		const answersArray = questions.map((q, idx) => ({
			questionId: q.id,
			selectedOptionId:
				idx < correctAnswers
					? questions[idx].options[1].id
					: questions[idx].options[0].id, // Select correct/incorrect option
			isCorrect: idx < correctAnswers,
			pointsEarned: idx < correctAnswers ? 10 : 0,
			answeredAt: faker.date.recent({ days: 7 }),
		}));

		return {
			id: v7(),
			driverId: driver.id,
			status: isCompleted ? ("COMPLETED" as const) : ("IN_PROGRESS" as const),
			totalQuestions: questions.length,
			correctAnswers,
			totalPoints,
			earnedPoints: totalPoints,
			passingScore: 70,
			scorePercentage,
			answers: answersArray,
			startedAt: faker.date.recent({ days: 30 }),
			completedAt: isCompleted ? faker.date.recent({ days: 7 }) : null,
			createdAt: new Date(),
			updatedAt: new Date(),
		};
	});

	await db.insert(driverQuizAnswer).values(answers);
	console.log(`‚úÖ Inserted ${answers.length} driver quiz answers.`);
}

async function seedCoupons() {
	console.log("üé´ Seeding Coupons...");

	const admin = await db
		.select()
		.from(tables.user)
		.where(eq(tables.user.email, "test-admin-1@akademove.com"))
		.then(([r]) => r);

	if (!admin) {
		console.warn("‚ö†Ô∏è Admin user not found. Skipping coupons.");
		return;
	}

	const merchants = await db.select({ id: merchant.id }).from(merchant);

	const coupons = [
		{
			name: "Welcome Discount",
			code: "WELCOME10",
			rules: {
				general: {
					type: "PERCENTAGE" as const,
					minOrderAmount: 15000,
					maxDiscountAmount: 5000,
				},
				user: {
					newUserOnly: true,
					perUserLimit: 1,
				},
			},
			discountPercentage: 10,
			usageLimit: 1000,
			usedCount: faker.number.int({ min: 0, max: 100 }),
			periodStart: new Date(),
			periodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
			isActive: true,
			createdById: admin.id,
		},
		{
			name: "First Ride Free",
			code: "FIRSTFREE",
			rules: {
				general: {
					type: "FIXED" as const,
					minOrderAmount: 10000,
					maxDiscountAmount: 10000,
				},
				user: {
					newUserOnly: true,
					perUserLimit: 1,
				},
			},
			discountAmount: 10000,
			usageLimit: 500,
			usedCount: faker.number.int({ min: 0, max: 50 }),
			periodStart: new Date(),
			periodEnd: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000), // 60 days
			isActive: true,
			createdById: admin.id,
		},
		{
			name: "Merchant Special",
			code: "MERCHANT20",
			rules: {
				general: {
					type: "PERCENTAGE" as const,
					minOrderAmount: 25000,
					maxDiscountAmount: 15000,
				},
			},
			discountPercentage: 20,
			usageLimit: 200,
			usedCount: faker.number.int({ min: 0, max: 20 }),
			periodStart: new Date(),
			periodEnd: new Date(Date.now() + 45 * 24 * 60 * 60 * 1000), // 45 days
			isActive: true,
			merchantId:
				merchants.length > 0
					? faker.helpers.arrayElement(merchants).id
					: undefined,
			createdById: admin.id,
		},
	];

	const couponData = coupons.map((c) => ({
		id: v7(),
		name: c.name,
		code: c.code,
		rules: c.rules,
		discountAmount: c.discountAmount,
		discountPercentage: c.discountPercentage,
		usageLimit: c.usageLimit,
		usedCount: c.usedCount,
		periodStart: c.periodStart,
		periodEnd: c.periodEnd,
		isActive: c.isActive,
		merchantId: c.merchantId,
		createdById: c.createdById,
		createdAt: new Date(),
		updatedAt: new Date(),
	}));

	await db.insert(coupon).values(couponData);
	console.log(`‚úÖ Inserted ${couponData.length} coupons.`);
}

async function seedBroadcasts() {
	console.log("üì¢ Seeding Broadcasts...");

	const admin = await db
		.select()
		.from(tables.user)
		.where(eq(tables.user.email, "test-admin-1@akademove.com"))
		.then(([r]) => r);

	if (!admin) {
		console.warn("‚ö†Ô∏è Admin user not found. Skipping broadcasts.");
		return;
	}

	const broadcasts = [
		{
			title: "Welcome to AkadeMove!",
			message:
				"Thank you for joining our campus mobility platform. Safe travels!",
			type: "IN_APP" as const,
			targetAudience: "ALL" as const,
			status: "SENT" as const,
			totalRecipients: 100,
			sentCount: 95,
			failedCount: 5,
			createdBy: admin.id,
			sentAt: faker.date.recent({ days: 7 }),
		},
		{
			title: "New Feature: Gender Preference",
			message:
				"You can now request drivers of a specific gender for added comfort and safety.",
			type: "IN_APP" as const,
			targetAudience: "USERS" as const,
			status: "SENT" as const,
			totalRecipients: 50,
			sentCount: 48,
			failedCount: 2,
			createdBy: admin.id,
			sentAt: faker.date.recent({ days: 14 }),
		},
		{
			title: "Driver Appreciation Week",
			message:
				"Show your appreciation to our amazing drivers! Leave reviews and earn bonus points.",
			type: "IN_APP" as const,
			targetAudience: "DRIVERS" as const,
			status: "PENDING" as const,
			scheduledAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
			createdBy: admin.id,
		},
	];

	const broadcastData = broadcasts.map((b) => ({
		id: v7(),
		title: b.title,
		message: b.message,
		type: b.type,
		targetAudience: b.targetAudience,
		status: b.status,
		scheduledAt: b.scheduledAt,
		sentAt: b.sentAt,
		totalRecipients: b.totalRecipients,
		sentCount: b.sentCount,
		failedCount: b.failedCount,
		createdBy: b.createdBy,
		createdAt: new Date(),
		updatedAt: new Date(),
	}));

	await db.insert(broadcast).values(broadcastData);
	console.log(`‚úÖ Inserted ${broadcastData.length} broadcasts.`);
}

async function seedReviews() {
	console.log("‚≠ê Seeding Reviews...");

	const completedOrders = await db
		.select({
			id: order.id,
			userId: order.userId,
			driverId: order.driverId,
			merchantId: order.merchantId,
			type: order.type,
		})
		.from(order)
		.where(eq(order.status, "COMPLETED"));

	if (completedOrders.length === 0) {
		console.warn("‚ö†Ô∏è No completed orders found. Skipping reviews.");
		return;
	}

	const reviews = completedOrders.map((order) => {
		const isFromUser = faker.datatype.boolean();
		const fromUserId = isFromUser
			? order.userId
			: order.driverId || order.userId;
		const toUserId = isFromUser ? order.driverId || order.userId : order.userId;

		return {
			id: v7(),
			orderId: order.id,
			fromUserId,
			toUserId,
			category: faker.helpers.arrayElement(CONSTANTS.REVIEW_CATEGORIES),
			score: faker.number.int({ min: 3, max: 5 }),
			comment: faker.lorem.sentence(),
			createdAt: faker.date.recent({ days: 30 }),
			updatedAt: faker.date.recent({ days: 30 }),
		};
	});

	await db.insert(review).values(reviews);
	console.log(`‚úÖ Inserted ${reviews.length} reviews.`);
}

async function seedTransactionsAndPayments() {
	console.log("üí≥ Seeding Transactions and Payments...");

	const orders = await db
		.select({
			id: order.id,
			userId: order.userId,
			totalPrice: order.totalPrice,
			status: order.status,
		})
		.from(order)
		.where(inArray(order.status, ["COMPLETED", "IN_TRIP"]));

	const wallets = await db
		.select({ id: tables.wallet.id, userId: tables.wallet.userId })
		.from(tables.wallet);

	const walletMap = Object.fromEntries(wallets.map((w) => [w.userId, w.id]));

	const transactions = [];
	const payments = [];

	for (const order of orders) {
		const walletId = walletMap[order.userId];
		if (!walletId) continue;

		const amount = order.totalPrice;
		const transactionId = v7();

		transactions.push({
			id: transactionId,
			walletId,
			type: "PAYMENT" as const,
			amount,
			balanceBefore: "100000", // Assume starting balance
			balanceAfter: `${100000 - Number(amount)}`,
			status: "COMPLETED" as const,
			description: `Payment for order ${order.id}`,
			referenceId: order.id,
			createdAt: faker.date.recent({ days: 30 }),
			updatedAt: faker.date.recent({ days: 30 }),
		});

		payments.push({
			id: v7(),
			transactionId,
			provider: "MIDTRANS" as const,
			method: "wallet" as const,
			amount,
			status: "COMPLETED" as const,
			externalId: `payment_${faker.string.alphanumeric(10)}`,
			createdAt: faker.date.recent({ days: 30 }),
			updatedAt: faker.date.recent({ days: 30 }),
		});
	}

	if (transactions.length > 0) {
		await db.insert(transaction).values(transactions);
		await db.insert(payment).values(payments);
		console.log(
			`‚úÖ Inserted ${transactions.length} transactions and payments.`,
		);
	} else {
		console.log("‚úÖ No transactions to seed.");
	}
}

async function seedLeaderboards() {
	console.log("üèÜ Seeding Leaderboards...");

	const drivers = await db
		.select({
			userId: driver.userId,
			rating: driver.rating,
		})
		.from(driver);

	const merchants = await db
		.select({
			userId: merchant.userId,
		})
		.from(merchant);

	const now = new Date();
	const periodStart = new Date(now.getFullYear(), now.getMonth(), 1);
	const periodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);

	const leaderboards = [];

	// Driver leaderboards
	drivers.forEach((driver, index) => {
		leaderboards.push({
			id: v7(),
			userId: driver.userId,
			driverId: driver.userId, // Assuming driver.userId is the driver record ID
			category: "DRIVER_RATING" as const,
			period: "MONTHLY" as const,
			rank: index + 1,
			score: Math.floor(driver.rating * 100),
			periodStart,
			periodEnd,
			createdAt: new Date(),
			updatedAt: new Date(),
		});
	});

	// Merchant leaderboards
	merchants.forEach((merchant, index) => {
		leaderboards.push({
			id: v7(),
			userId: merchant.userId,
			merchantId: merchant.userId, // Assuming merchant.userId is the merchant record ID
			category: "MERCHANT_ORDERS" as const,
			period: "MONTHLY" as const,
			rank: index + 1,
			score: faker.number.int({ min: 10, max: 100 }),
			periodStart,
			periodEnd,
			createdAt: new Date(),
			updatedAt: new Date(),
		});
	});

	await db.insert(leaderboard).values(leaderboards);
	console.log(`‚úÖ Inserted ${leaderboards.length} leaderboard entries.`);
}

async function seedNotifications() {
	console.log("üîî Seeding Notifications...");

	const users = await db
		.select({ id: tables.user.id })
		.from(tables.user)
		.limit(20);

	const fcmTokens = users.map((user) => ({
		id: v7(),
		userId: user.id,
		token: faker.string.alphanumeric(152), // FCM token length
		createdAt: new Date(),
		updatedAt: new Date(),
	}));

	await db.insert(fcmToken).values(fcmTokens);

	const notifications = users.flatMap((user) => [
		{
			id: v7(),
			userId: user.id,
			title: "Welcome to AkadeMove!",
			body: "Your account has been successfully created.",
			data: { type: "welcome" },
			isRead: faker.datatype.boolean(),
			createdAt: faker.date.recent({ days: 30 }),
			readAt: faker.datatype.boolean() ? faker.date.recent({ days: 7 }) : null,
		},
		{
			id: v7(),
			userId: user.id,
			title: "Order Completed",
			body: "Your recent order has been completed successfully.",
			data: { type: "order_completed" },
			isRead: faker.datatype.boolean(),
			createdAt: faker.date.recent({ days: 14 }),
			readAt: faker.datatype.boolean() ? faker.date.recent({ days: 7 }) : null,
		},
	]);

	await db.insert(userNotification).values(notifications);
	console.log(
		`‚úÖ Inserted ${fcmTokens.length} FCM tokens and ${notifications.length} user notifications.`,
	);
}

async function seedSupportTickets() {
	console.log("üé´ Seeding Support Tickets...");

	const users = await db
		.select({ id: tables.user.id })
		.from(tables.user)
		.limit(10);

	const operators = await db
		.select({ id: tables.user.id })
		.from(tables.user)
		.where(eq(tables.user.role, "OPERATOR"));

	const orders = await db.select({ id: order.id }).from(order).limit(5);

	const tickets = users.map((user, index) => ({
		id: v7(),
		userId: user.id,
		assignedToId:
			operators.length > 0 && index % 3 === 0
				? faker.helpers.arrayElement(operators).id
				: null,
		subject: faker.lorem.sentence(),
		category: faker.helpers.arrayElement([
			"GENERAL",
			"ORDER_ISSUE",
			"PAYMENT_ISSUE",
			"TECHNICAL_ISSUE",
		]),
		priority: faker.helpers.arrayElement(["LOW", "MEDIUM", "HIGH"]),
		status: faker.helpers.arrayElement(["OPEN", "IN_PROGRESS", "RESOLVED"]),
		orderId:
			orders.length > 0 && index % 2 === 0
				? faker.helpers.arrayElement(orders).id
				: null,
		lastMessageAt: faker.date.recent({ days: 7 }),
		createdAt: faker.date.recent({ days: 30 }),
		updatedAt: faker.date.recent({ days: 7 }),
	}));

	await db.insert(supportTicket).values(tickets);

	// Add some chat messages for each ticket
	const messages = [];
	for (const ticket of tickets) {
		const messageCount = faker.number.int({ min: 1, max: 5 });
		for (let i = 0; i < messageCount; i++) {
			messages.push({
				id: v7(),
				ticketId: ticket.id,
				senderId: faker.datatype.boolean()
					? ticket.userId
					: ticket.assignedToId || ticket.userId,
				message: faker.lorem.sentence(),
				isFromSupport: ticket.assignedToId ? faker.datatype.boolean() : false,
				sentAt: faker.date.recent({ days: 7 }),
				createdAt: faker.date.recent({ days: 7 }),
				updatedAt: faker.date.recent({ days: 7 }),
			});
		}
	}

	await db.insert(supportChatMessage).values(messages);
	console.log(
		`‚úÖ Inserted ${tickets.length} support tickets and ${messages.length} chat messages.`,
	);
}

async function seedOrderChatMessages() {
	console.log("üí¨ Seeding Order Chat Messages...");

	const orders = await db
		.select({
			id: order.id,
			userId: order.userId,
			driverId: order.driverId,
		})
		.from(order)
		.where(sql`${order.driverId} IS NOT NULL`)
		.limit(10);

	const messages = [];
	for (const order of orders) {
		const messageCount = faker.number.int({ min: 1, max: 3 });
		for (let i = 0; i < messageCount; i++) {
			const isFromUser = faker.datatype.boolean();
			messages.push({
				id: v7(),
				orderId: order.id,
				senderId: isFromUser ? order.userId : order.driverId || order.userId,
				message: faker.lorem.sentence(),
				sentAt: faker.date.recent({ days: 7 }),
				createdAt: faker.date.recent({ days: 7 }),
				updatedAt: faker.date.recent({ days: 7 }),
			});
		}
	}

	await db.insert(orderChatMessage).values(messages);
	console.log(`‚úÖ Inserted ${messages.length} order chat messages.`);
}

async function seedMiscellaneousTables() {
	console.log("üìÑ Seeding Miscellaneous Tables...");

	// Seed newsletters
	const users = await db
		.select({ id: tables.user.id, email: tables.user.email })
		.from(tables.user)
		.limit(20);

	const newsletters = users.map((user) => ({
		id: v7(),
		email: user.email,
		status: faker.helpers.arrayElement(["ACTIVE", "UNSUBSCRIBED"]),
		userId: faker.datatype.boolean() ? user.id : null,
		createdAt: faker.date.recent({ days: 90 }),
		updatedAt: faker.date.recent({ days: 30 }),
	}));

	await db.insert(newsletter).values(newsletters);

	// Seed contacts
	const contacts = Array.from({ length: 10 }).map(() => ({
		id: v7(),
		name: faker.person.fullName(),
		email: faker.internet.email(),
		subject: faker.lorem.sentence(),
		message: faker.lorem.paragraph(),
		status: faker.helpers.arrayElement(["PENDING", "REVIEWING", "RESOLVED"]),
		userId: faker.datatype.boolean()
			? faker.helpers.arrayElement(users).id
			: null,
		respondedById: faker.datatype.boolean()
			? faker.helpers.arrayElement(users).id
			: null,
		response: faker.datatype.boolean() ? faker.lorem.paragraph() : null,
		createdAt: faker.date.recent({ days: 60 }),
		updatedAt: faker.date.recent({ days: 30 }),
		respondedAt: faker.datatype.boolean()
			? faker.date.recent({ days: 30 })
			: null,
	}));

	await db.insert(contact).values(contacts);

	// Seed reports
	const reports = Array.from({ length: 5 }).map(() => {
		const reporter = faker.helpers.arrayElement(users);
		const target = faker.helpers.arrayElement(
			users.filter((u) => u.id !== reporter.id),
		);
		const orders = []; // Would need to fetch actual orders

		return {
			id: v7(),
			orderId: null, // For simplicity
			reporterId: reporter.id,
			targetUserId: target.id,
			category: faker.helpers.arrayElement(CONSTANTS.REPORT_CATEGORIES),
			description: faker.lorem.paragraph(),
			status: faker.helpers.arrayElement(CONSTANTS.REPORT_STATUS),
			handledById: faker.datatype.boolean()
				? faker.helpers.arrayElement(users).id
				: null,
			resolution: faker.datatype.boolean() ? faker.lorem.sentence() : null,
			reportedAt: faker.date.recent({ days: 30 }),
			resolvedAt: faker.datatype.boolean()
				? faker.date.recent({ days: 7 })
				: null,
		};
	});

	await db.insert(report).values(reports);

	// Seed emergencies
	const emergencies = Array.from({ length: 3 }).map(() => {
		const user = faker.helpers.arrayElement(users);
		const orders = []; // Would need to fetch actual orders

		return {
			id: v7(),
			orderId: null, // For simplicity
			userId: user.id,
			type: faker.helpers.arrayElement(CONSTANTS.EMERGENCY_TYPES),
			status: faker.helpers.arrayElement(CONSTANTS.EMERGENCY_STATUS),
			description: faker.lorem.paragraph(),
			location: sql`ST_SetSRID(ST_MakePoint(${faker.location.longitude()}, ${faker.location.latitude()}), 4326)`,
			reportedAt: faker.date.recent({ days: 14 }),
		};
	});

	await db.insert(emergency).values(emergencies);

	// Seed account deletions
	const accountDeletions = Array.from({ length: 2 }).map(() => {
		const user = faker.helpers.arrayElement(users);

		return {
			id: v7(),
			fullName: faker.person.fullName(),
			email: user.email,
			phone: faker.phone.number(),
			accountType: faker.helpers.arrayElement(["USER", "DRIVER", "MERCHANT"]),
			reason: faker.helpers.arrayElement([
				"NO_LONGER_NEEDED",
				"PRIVACY_CONCERNS",
				"SWITCHING_SERVICE",
				"OTHER",
			]),
			additionalInfo: faker.datatype.boolean() ? faker.lorem.sentence() : null,
			status: faker.helpers.arrayElement(["PENDING", "APPROVED", "REJECTED"]),
			userId: faker.datatype.boolean() ? user.id : null,
			reviewedById: faker.datatype.boolean()
				? faker.helpers.arrayElement(users).id
				: null,
			reviewNotes: faker.datatype.boolean() ? faker.lorem.sentence() : null,
			createdAt: faker.date.recent({ days: 60 }),
			updatedAt: faker.date.recent({ days: 30 }),
			reviewedAt: faker.datatype.boolean()
				? faker.date.recent({ days: 30 })
				: null,
			completedAt: faker.datatype.boolean()
				? faker.date.recent({ days: 7 })
				: null,
		};
	});

	await db.insert(accountDeletion).values(accountDeletions);

	console.log(
		`‚úÖ Inserted miscellaneous data: ${newsletters.length} newsletters, ${contacts.length} contacts, ${reports.length} reports, ${emergencies.length} emergencies, ${accountDeletions.length} account deletions.`,
	);
}

async function seedBadges() {
	type Insert = Omit<InsertBadge, "icon"> & {
		iconPath: string;
	};
	const DEFAULT_BADGES: Insert[] = [
		// ==========================================
		// USER BADGES (Passengers)
		// ==========================================
		{
			code: "NEW_CUSTOMER",
			name: "New Customer",
			description: "Welcome to the akademove community!",
			type: "ACHIEVEMENT",
			level: "BRONZE",
			targetRole: "USER",
			criteria: {
				minOrders: 0,
			},
			isActive: true,
			displayOrder: 100,
			iconPath: "assets/New-Customer.png",
		},
		{
			code: "FIRST_RIDE",
			name: "First Ride",
			description: "Complete your first ride successfully",
			type: "ACHIEVEMENT",
			level: "BRONZE",
			targetRole: "USER",
			criteria: {
				minOrders: 1,
			},
			isActive: true,
			displayOrder: 1,
			iconPath: "assets/First-Ride.png",
		},
		{
			code: "FREQUENT_RIDER",
			name: "Frequent Rider",
			description: "Complete 50 rides",
			type: "MILESTONE",
			level: "SILVER",
			targetRole: "USER",
			criteria: {
				minOrders: 50,
			},
			isActive: true,
			displayOrder: 10,
			iconPath: "assets/Frequent-Rider.png",
		},
		{
			code: "SUPER_RIDER",
			name: "Super Rider",
			description: "Complete 100 rides",
			type: "MILESTONE",
			level: "GOLD",
			targetRole: "USER",
			criteria: {
				minOrders: 100,
			},
			isActive: true,
			displayOrder: 11,
			iconPath: "assets/Super-Rider.png",
		},
		{
			code: "ELITE_RIDER",
			name: "Elite Rider",
			description: "Complete 500 rides",
			type: "MILESTONE",
			level: "PLATINUM",
			targetRole: "USER",
			criteria: {
				minOrders: 500,
			},
			isActive: true,
			displayOrder: 12,
			iconPath: "assets/Elite-Rider.png",
		},

		// ==========================================
		// DRIVER BADGES
		// ==========================================
		{
			code: "NEW_DRIVER",
			name: "New Driver",
			description: "Welcome to the driver community!",
			type: "ACHIEVEMENT",
			level: "BRONZE",
			targetRole: "DRIVER",
			criteria: {
				minOrders: 0,
			},
			isActive: true,
			displayOrder: 100,
			iconPath: "assets/New-Driver.png",
		},
		{
			code: "FIRST_TRIP",
			name: "First Trip",
			description: "Complete your first trip as a driver",
			type: "ACHIEVEMENT",
			level: "BRONZE",
			targetRole: "DRIVER",
			criteria: {
				minOrders: 1,
			},
			isActive: true,
			displayOrder: 101,
			iconPath: "assets/First-Trip.png",
		},
		{
			code: "RELIABLE_DRIVER",
			name: "Reliable Driver",
			description: "Maintain 4.5+ rating with 50 completed rides",
			type: "PERFORMANCE",
			level: "SILVER",
			targetRole: "DRIVER",
			criteria: {
				minOrders: 50,
				minRating: 4.5,
			},
			benefits: {
				priorityBoost: 10,
			},
			isActive: true,
			displayOrder: 110,
			iconPath: "assets/Reliable-Driver.png",
		},
		{
			code: "STAR_DRIVER",
			name: "Star Driver",
			description: "Maintain 4.8+ rating with 100 completed rides",
			type: "PERFORMANCE",
			level: "GOLD",
			targetRole: "DRIVER",
			criteria: {
				minOrders: 100,
				minRating: 4.8,
			},
			benefits: {
				priorityBoost: 20,
				commissionReduction: 0.05,
			},
			isActive: true,
			displayOrder: 111,
			iconPath: "assets/Star-Driver.png",
		},
		{
			code: "ELITE_DRIVER",
			name: "Elite Driver",
			description: "Maintain 4.9+ rating with 500 completed rides",
			type: "PERFORMANCE",
			level: "PLATINUM",
			targetRole: "DRIVER",
			criteria: {
				minOrders: 500,
				minRating: 4.9,
			},
			benefits: {
				priorityBoost: 30,
				commissionReduction: 0.1,
			},
			isActive: true,
			displayOrder: 112,
			iconPath: "assets/Elite-Driver.png",
		},
		{
			code: "CENTURION",
			name: "Centurion",
			description: "Complete 100 rides",
			type: "MILESTONE",
			level: "GOLD",
			targetRole: "DRIVER",
			criteria: {
				minOrders: 100,
			},
			benefits: {
				priorityBoost: 15,
			},
			isActive: true,
			displayOrder: 120,
			iconPath: "assets/Centurion.png",
		},

		// ==========================================
		// MERCHANT BADGES
		// ==========================================
		{
			code: "NEW_MERCHANT",
			name: "New Merchant",
			description: "Welcome to the merchant community!",
			type: "ACHIEVEMENT",
			level: "BRONZE",
			targetRole: "MERCHANT",
			criteria: {
				minOrders: 0,
			},
			isActive: true,
			displayOrder: 200,
			iconPath: "assets/New-Merchant.png",
		},
		{
			code: "FIRST_ORDER",
			name: "First Order",
			description: "Receive your first order",
			type: "ACHIEVEMENT",
			level: "BRONZE",
			targetRole: "MERCHANT",
			criteria: {
				minOrders: 1,
			},
			isActive: true,
			displayOrder: 201,
			iconPath: "assets/First-Order.png",
		},
		{
			code: "POPULAR_MERCHANT",
			name: "Popular Merchant",
			description: "Complete 50 orders with 4.5+ rating",
			type: "PERFORMANCE",
			level: "SILVER",
			targetRole: "MERCHANT",
			criteria: {
				minOrders: 50,
				minRating: 4.5,
			},
			benefits: {
				priorityBoost: 10,
			},
			isActive: true,
			displayOrder: 210,
			iconPath: "assets/Popular-Merchant.png",
		},
		{
			code: "TOP_RATED_MERCHANT",
			name: "Top Rated Merchant",
			description: "Maintain 4.8+ rating with 100 orders",
			type: "PERFORMANCE",
			level: "GOLD",
			targetRole: "MERCHANT",
			criteria: {
				minOrders: 100,
				minRating: 4.8,
			},
			benefits: {
				priorityBoost: 20,
				commissionReduction: 0.05,
			},
			isActive: true,
			displayOrder: 211,
			iconPath: "assets/Top-Rated-Merchant.png",
		},
	];
	const cwd = process.cwd();

	console.log("üéñÔ∏è Seeding Badges...");

	await Promise.all([
		db
			.insert(tables.badge)
			.values(
				DEFAULT_BADGES.map((e) => ({ ...e, id: v7(), icon: `${e.code}.png` })),
			)
			.onConflictDoNothing(),
		...DEFAULT_BADGES.map(async (badge) => {
			const filePath = join(cwd, badge.iconPath);
			const buff = await readFile(filePath);
			const fileName = `${badge.code}.png`;

			const file = new File([buff], fileName, {
				type: "image/png",
				lastModified: Date.now(),
			});

			return storage.upload({
				bucket: "badges",
				key: fileName,
				file,
			});
		}),
	]);

	console.log("‚úÖ Badges seeded successfully.");
}

async function seedUserBadges() {
	console.log("üèÖ Seeding User Badges...");

	const [
		testUser,
		testDriver,
		testMerchant,
		newCustomerBadge,
		newDriverBadge,
		newMerchantBadge,
	] = await Promise.all([
		db
			.select()
			.from(tables.user)
			.where(eq(tables.user.email, "test-user-1@akademove.com"))
			.then(([r]) => r),
		db
			.select()
			.from(tables.user)
			.where(eq(tables.user.email, "test-driver-1@akademove.com"))
			.then(([r]) => r),
		db
			.select()
			.from(tables.user)
			.where(eq(tables.user.email, "test-merchant-1@akademove.com"))
			.then(([r]) => r),
		db
			.select()
			.from(tables.badge)
			.where(eq(tables.badge.code, "NEW_CUSTOMER"))
			.then(([r]) => r),
		db
			.select()
			.from(tables.badge)
			.where(eq(tables.badge.code, "NEW_DRIVER"))
			.then(([r]) => r),
		db
			.select()
			.from(tables.badge)
			.where(eq(tables.badge.code, "NEW_MERCHANT"))
			.then(([r]) => r),
	]);

	if (
		!testUser ||
		!testDriver ||
		!testMerchant ||
		!newCustomerBadge ||
		!newDriverBadge ||
		!newMerchantBadge
	) {
		console.warn(
			"‚ö†Ô∏è Required test users or badges not found. Skipping user badges.",
		);
		return;
	}

	const values = [
		{
			id: v7(),
			userId: testUser.id,
			badgeId: newCustomerBadge.id,
		},
		{
			id: v7(),
			userId: testDriver.id,
			badgeId: newDriverBadge.id,
		},
		{
			id: v7(),
			userId: testMerchant.id,
			badgeId: newMerchantBadge.id,
		},
	];

	await db.insert(tables.userBadge).values(values).onConflictDoNothing();
	console.log("‚úÖ User badges assigned successfully.");
}

async function main() {
	try {
		await confirmExecution();

		const options = await promptSeedingOptions();

		console.log("\nüå± Starting database seeding...\n");

		// Determine which seeders to run
		const shouldRun = (seeder: string) => {
			if (options.mode === "all") return true;
			return options.seeders.has(seeder);
		};

		// Phase 1: Foundation data (users and badges)
		const phase1: Promise<void>[] = [];

		if (shouldRun("users")) {
			phase1.push(seedUser(options.mode === "base"));
		}
		if (shouldRun("badges")) {
			phase1.push(seedBadges());
		}

		if (phase1.length > 0) {
			await Promise.all(phase1);
		}

		// Phase 2: Dependent data (requires users to exist)
		const phase2: Promise<void>[] = [];

		if (shouldRun("userBadges")) {
			phase2.push(seedUserBadges());
		}
		if (shouldRun("configurations")) {
			phase2.push(seedConfigurations());
		}
		if (shouldRun("merchants")) {
			phase2.push(seedMerchants());
		}
		if (shouldRun("drivers")) {
			phase2.push(seedDrivers());
		}
		// Note: Additional seeders for driverQuiz, coupons, broadcasts would go here
		// but are omitted due to complex schema requirements

		if (phase2.length > 0) {
			await Promise.all(phase2);
		}

		// Phase 3: Orders and related data (requires users, drivers, merchants)
		const phase3: Promise<void>[] = [];

		if (shouldRun("orders")) {
			phase3.push(seedOrders());
		}

		if (phase3.length > 0) {
			await Promise.all(phase3);
		}

		// Phase 4: Additional seeders could be implemented here for:
		// - reviews (order reviews)
		// - transactions and payments
		// - leaderboards
		// - notifications (FCM tokens, user notifications)
		// - support tickets and chat messages
		// - order chat messages
		// - reports, contacts, newsletters, emergencies, account deletions
		//
		// These are omitted due to complex schema requirements and time constraints,
		// but the framework is in place for future implementation.

		console.log("\n‚úÖ Database seeded successfully.");
	} catch (error) {
		console.error("\n‚ùå Seeding failed:", error);
		process.exit(1);
	} finally {
		await client.end();
		process.exit(0);
	}
}

main();
